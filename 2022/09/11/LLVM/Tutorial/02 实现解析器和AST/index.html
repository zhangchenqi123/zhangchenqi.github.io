<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>02 实现解析器和AST | 牛衣古柳卖黄瓜</title>
  <meta name="keywords" content=" LLVM , tutorial ">
  <meta name="description" content="02 实现解析器和AST | 牛衣古柳卖黄瓜">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta property="og:type" content="website">
<meta property="og:title" content="categories">
<meta property="og:url" content="https://zhangchenqi123.github.io/categories/index.html">
<meta property="og:site_name" content="牛衣古柳卖黄瓜">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-31T02:03:35.000Z">
<meta property="article:modified_time" content="2022-03-31T02:04:02.527Z">
<meta property="article:author" content="zcq">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/1.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/sublime.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.1.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/1.jpg"/>
</a>
<div class="author">
    <span>zcq</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/zhangchenqi123"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/niu-yi-gu-liu-mai-huang-gua-15"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:1149440709@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=1149440709&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=1486265675"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(35)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="论文">
                        
                        论文
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="其他">
                        
                        其他
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="算法">
                        <i class="fold iconfont icon-right"></i>
                        
                        算法
                        <small>(22)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="算法<--->acwing">
                                        
                                        acwing
                                        
                                            <small>(15
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="算法<--->sjtu机试">
                                        
                                        sjtu机试
                                        
                                            <small>(6
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="LLVM">
                        <i class="fold iconfont icon-right"></i>
                        
                        LLVM
                        <small>(5)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="LLVM<--->Tutorial">
                                        
                                        Tutorial
                                        
                                            <small>(5
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="MLIR">
                        
                        MLIR
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="35">
<input type="hidden" id="yelog_site_word_count" value="71.7k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>补充知识</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>差分</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>动态规划</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>二分</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>构造法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>机试</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>论文</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>论文笔记</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>枚举</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>模拟</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数学</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>双指针</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>思维题</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>算法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>贪心</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>图论</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>BFS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>DFS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>LLVM</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MLIR</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>trick</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>tutorial</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a id="top" class="全部文章 论文 "
           href="/2022/09/08/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/Else/"
           data-tag="论文,论文笔记"
           data-author="" >
            <span class="post-title" title="00_如何通过文献掌握学术动态">00_如何通过文献掌握学术动态</span>
            <span class="post-date" title="2022-09-08 21:44:17">2022/09/08</span>
        </a>
        
        <a id="top" class="全部文章 论文 "
           href="/2022/09/08/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/00_How%20to%20Read%20a%20Paper/"
           data-tag="论文,论文笔记"
           data-author="" >
            <span class="post-title" title="00_How to read a paper">00_How to read a paper</span>
            <span class="post-date" title="2022-09-08 20:55:43">2022/09/08</span>
        </a>
        
        <a  class="全部文章 其他 "
           href="/2022/09/17/%E5%85%B6%E4%BB%96/HeteroCL%E7%AE%80%E4%BB%8B/"
           data-tag="补充知识"
           data-author="" >
            <span class="post-title" title="HeteroCL简介">HeteroCL简介</span>
            <span class="post-date" title="2022-09-17 15:22:36">2022/09/17</span>
        </a>
        
        <a  class="全部文章 论文 "
           href="/2022/09/16/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/02_MLIR%20A%20Compiler%20Infrastructure%20for%20the%20End%20of%20Moore%E2%80%99s%20Law/"
           data-tag="论文,论文笔记,MLIR"
           data-author="" >
            <span class="post-title" title="02_MLIR A Compiler Infrastructure for the End of Moore’s Law">02_MLIR A Compiler Infrastructure for the End of Moore’s Law</span>
            <span class="post-date" title="2022-09-16 16:36:15">2022/09/16</span>
        </a>
        
        <a  class="全部文章 LLVM Tutorial "
           href="/2022/09/14/LLVM/Tutorial/04%20%E6%B7%BB%E5%8A%A0JIT%E5%92%8C%E4%BC%98%E5%8C%96%E6%94%AF%E6%8C%81/"
           data-tag="LLVM,tutorial"
           data-author="" >
            <span class="post-title" title="04 添加JIT和优化支持">04 添加JIT和优化支持</span>
            <span class="post-date" title="2022-09-14 15:55:04">2022/09/14</span>
        </a>
        
        <a  class="全部文章 LLVM Tutorial "
           href="/2022/09/13/LLVM/Tutorial/03%20LLVM%20IR%20%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/"
           data-tag="LLVM,tutorial"
           data-author="" >
            <span class="post-title" title="03 LLVM IR 代码生成">03 LLVM IR 代码生成</span>
            <span class="post-date" title="2022-09-13 20:36:50">2022/09/13</span>
        </a>
        
        <a  class="全部文章 LLVM Tutorial "
           href="/2022/09/11/LLVM/Tutorial/02%20%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90%E5%99%A8%E5%92%8CAST/"
           data-tag="LLVM,tutorial"
           data-author="" >
            <span class="post-title" title="02 实现解析器和AST">02 实现解析器和AST</span>
            <span class="post-date" title="2022-09-11 20:49:39">2022/09/11</span>
        </a>
        
        <a  class="全部文章 LLVM Tutorial "
           href="/2022/09/11/LLVM/Tutorial/01%20Kaleidoscope%20%E8%AF%AD%E8%A8%80%E5%92%8C%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/"
           data-tag="LLVM,tutorial"
           data-author="" >
            <span class="post-title" title="01 Kaleidoscope 语言和词法分析器">01 Kaleidoscope 语言和词法分析器</span>
            <span class="post-date" title="2022-09-11 10:51:31">2022/09/11</span>
        </a>
        
        <a  class="全部文章 LLVM Tutorial "
           href="/2022/09/11/LLVM/Tutorial/00_%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%20LLVM%20%E8%AF%AD%E8%A8%80%E5%89%8D%E7%AB%AF/"
           data-tag="LLVM,tutorial"
           data-author="" >
            <span class="post-title" title="00 我的第一个 LLVM 语言前端">00 我的第一个 LLVM 语言前端</span>
            <span class="post-date" title="2022-09-11 10:00:15">2022/09/11</span>
        </a>
        
        <a  class="全部文章 "
           href="/2022/09/11/MLIR/Toy/01_Toy%20Language%20and%20AST/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2022-09-11 09:06:59">2022/09/11</span>
        </a>
        
        <a  class="全部文章 "
           href="/2022/09/08/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E6%A8%A1%E6%9D%BF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2022-09-08 20:53:27">2022/09/08</span>
        </a>
        
        <a  class="全部文章 论文 "
           href="/2022/09/08/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/01_ScaleHLS/"
           data-tag="论文,论文笔记,MLIR"
           data-author="" >
            <span class="post-title" title="01_ScaleHLS">01_ScaleHLS</span>
            <span class="post-date" title="2022-09-08 20:50:37">2022/09/08</span>
        </a>
        
        <a  class="全部文章 MLIR "
           href="/2022/09/08/MLIR/MLIR%E7%AE%80%E4%BB%8B/"
           data-tag="MLIR"
           data-author="" >
            <span class="post-title" title="00_MLIR简介">00_MLIR简介</span>
            <span class="post-date" title="2022-09-08 08:53:53">2022/09/08</span>
        </a>
        
        <a  class="全部文章 算法 sjtu机试 "
           href="/2022/07/02/%E7%AE%97%E6%B3%95/sjtu%E6%9C%BA%E8%AF%95/STL/"
           data-tag="算法,模拟"
           data-author="" >
            <span class="post-title" title="STL">STL</span>
            <span class="post-date" title="2022-07-02 02:41:38">2022/07/02</span>
        </a>
        
        <a  class="全部文章 算法 sjtu机试 "
           href="/2022/07/02/%E7%AE%97%E6%B3%95/sjtu%E6%9C%BA%E8%AF%95/acwing/"
           data-tag="算法,模拟"
           data-author="" >
            <span class="post-title" title="acwing">acwing</span>
            <span class="post-date" title="2022-07-02 02:41:38">2022/07/02</span>
        </a>
        
        <a  class="全部文章 算法 sjtu机试 "
           href="/2022/07/02/%E7%AE%97%E6%B3%95/sjtu%E6%9C%BA%E8%AF%95/%E5%86%99%E6%B3%95/"
           data-tag="算法,模拟"
           data-author="" >
            <span class="post-title" title="写法">写法</span>
            <span class="post-date" title="2022-07-02 02:41:38">2022/07/02</span>
        </a>
        
        <a  class="全部文章 算法 sjtu机试 "
           href="/2022/07/02/%E7%AE%97%E6%B3%95/sjtu%E6%9C%BA%E8%AF%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"
           data-tag="算法,模拟"
           data-author="" >
            <span class="post-title" title="字符串">字符串</span>
            <span class="post-date" title="2022-07-02 02:41:38">2022/07/02</span>
        </a>
        
        <a  class="全部文章 算法 sjtu机试 "
           href="/2022/07/02/%E7%AE%97%E6%B3%95/sjtu%E6%9C%BA%E8%AF%95/%E5%BE%80%E5%B9%B4%E9%A2%98/"
           data-tag="算法,模拟"
           data-author="" >
            <span class="post-title" title="sjtu往年题">sjtu往年题</span>
            <span class="post-date" title="2022-07-02 02:41:38">2022/07/02</span>
        </a>
        
        <a  class="全部文章 算法 sjtu机试 "
           href="/2022/07/02/%E7%AE%97%E6%B3%95/sjtu%E6%9C%BA%E8%AF%95/%E6%A8%A1%E6%8B%9F%E9%A2%98/"
           data-tag="机试,模拟"
           data-author="" >
            <span class="post-title" title="模拟题">模拟题</span>
            <span class="post-date" title="2022-07-02 02:41:38">2022/07/02</span>
        </a>
        
        <a  class="全部文章 算法 acwing "
           href="/2022/04/15/%E7%AE%97%E6%B3%95/acwing/%E5%9B%BE%E8%AE%BA_%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"
           data-tag="算法,图论"
           data-author="" >
            <span class="post-title" title="图论_单源最短路问题">图论_单源最短路问题</span>
            <span class="post-date" title="2022-04-15 11:23:49">2022/04/15</span>
        </a>
        
        <a  class="全部文章 算法 acwing "
           href="/2022/04/10/%E7%AE%97%E6%B3%95/acwing/%E4%BA%8C%E5%88%86/"
           data-tag="算法,二分"
           data-author="" >
            <span class="post-title" title="二分">二分</span>
            <span class="post-date" title="2022-04-10 22:57:08">2022/04/10</span>
        </a>
        
        <a  class="全部文章 算法 acwing "
           href="/2022/04/10/%E7%AE%97%E6%B3%95/acwing/%E6%8E%92%E5%BA%8F/"
           data-tag="算法,排序"
           data-author="" >
            <span class="post-title" title="排序">排序</span>
            <span class="post-date" title="2022-04-10 22:57:08">2022/04/10</span>
        </a>
        
        <a  class="全部文章 算法 acwing "
           href="/2022/04/10/%E7%AE%97%E6%B3%95/acwing/%E6%9E%84%E9%80%A0/"
           data-tag="算法,构造法"
           data-author="" >
            <span class="post-title" title="构造">构造</span>
            <span class="post-date" title="2022-04-10 22:47:34">2022/04/10</span>
        </a>
        
        <a  class="全部文章 算法 acwing "
           href="/2022/04/10/%E7%AE%97%E6%B3%95/acwing/%E6%9E%9A%E4%B8%BE/"
           data-tag="算法,枚举"
           data-author="" >
            <span class="post-title" title="枚举">枚举</span>
            <span class="post-date" title="2022-04-10 21:55:41">2022/04/10</span>
        </a>
        
        <a  class="全部文章 算法 acwing "
           href="/2022/03/31/%E7%AE%97%E6%B3%95/acwing/trick/"
           data-tag="算法,trick"
           data-author="" >
            <span class="post-title" title="trick">trick</span>
            <span class="post-date" title="2022-03-31 19:33:36">2022/03/31</span>
        </a>
        
        <a  class="全部文章 算法 "
           href="/2022/03/31/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%9201/"
           data-tag="算法,动态规划"
           data-author="" >
            <span class="post-title" title="动态规划01">动态规划01</span>
            <span class="post-date" title="2022-03-31 13:22:19">2022/03/31</span>
        </a>
        
        <a  class="全部文章 算法 acwing "
           href="/2022/03/31/%E7%AE%97%E6%B3%95/acwing/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"
           data-tag="算法,动态规划"
           data-author="" >
            <span class="post-title" title="动态规划">动态规划</span>
            <span class="post-date" title="2022-03-31 13:22:19">2022/03/31</span>
        </a>
        
        <a  class="全部文章 算法 acwing "
           href="/2022/03/31/%E7%AE%97%E6%B3%95/acwing/%E6%80%9D%E7%BB%B4%E9%A2%98/"
           data-tag="算法,思维题"
           data-author="" >
            <span class="post-title" title="思维题">思维题</span>
            <span class="post-date" title="2022-03-31 13:22:19">2022/03/31</span>
        </a>
        
        <a  class="全部文章 算法 acwing "
           href="/2022/03/31/%E7%AE%97%E6%B3%95/acwing/%E5%B7%AE%E5%88%86/"
           data-tag="算法,差分"
           data-author="" >
            <span class="post-title" title="差分">差分</span>
            <span class="post-date" title="2022-03-31 13:22:19">2022/03/31</span>
        </a>
        
        <a  class="全部文章 算法 acwing "
           href="/2022/03/31/%E7%AE%97%E6%B3%95/acwing/%E5%9B%BE%E8%AE%BA_%E5%9F%BA%E7%A1%80/"
           data-tag="算法,图论"
           data-author="" >
            <span class="post-title" title="图论_基础">图论_基础</span>
            <span class="post-date" title="2022-03-31 13:22:19">2022/03/31</span>
        </a>
        
        <a  class="全部文章 算法 acwing "
           href="/2022/03/31/%E7%AE%97%E6%B3%95/acwing/%E6%95%B0%E5%AD%A6/"
           data-tag="算法,数学"
           data-author="" >
            <span class="post-title" title="数学">数学</span>
            <span class="post-date" title="2022-03-31 13:22:19">2022/03/31</span>
        </a>
        
        <a  class="全部文章 算法 acwing "
           href="/2022/03/31/%E7%AE%97%E6%B3%95/acwing/%E8%B4%AA%E5%BF%83/"
           data-tag="算法,贪心"
           data-author="" >
            <span class="post-title" title="贪心">贪心</span>
            <span class="post-date" title="2022-03-31 13:22:19">2022/03/31</span>
        </a>
        
        <a  class="全部文章 算法 acwing "
           href="/2022/03/31/%E7%AE%97%E6%B3%95/acwing/%E5%8F%8C%E6%8C%87%E9%92%88/"
           data-tag="算法,双指针"
           data-author="" >
            <span class="post-title" title="双指针">双指针</span>
            <span class="post-date" title="2022-03-31 13:22:13">2022/03/31</span>
        </a>
        
        <a  class="全部文章 算法 acwing "
           href="/2022/03/31/%E7%AE%97%E6%B3%95/acwing/BFS/"
           data-tag="算法,BFS"
           data-author="" >
            <span class="post-title" title="BFS">BFS</span>
            <span class="post-date" title="2022-03-31 13:19:34">2022/03/31</span>
        </a>
        
        <a  class="全部文章 算法 acwing "
           href="/2022/03/31/%E7%AE%97%E6%B3%95/acwing/DFS/"
           data-tag="算法,DFS"
           data-author="" >
            <span class="post-title" title="DFS">DFS</span>
            <span class="post-date" title="2022-03-31 13:19:29">2022/03/31</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-LLVM/Tutorial/02 实现解析器和AST" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">02 实现解析器和AST</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="LLVM">LLVM</a> > 
            
            <a  data-rel="LLVM&lt;---&gt;Tutorial">Tutorial</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">LLVM</a>
            
            <a class="color4">tutorial</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2022-09-13 20:36:47'>2022-09-11 20:49</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:6.2k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">2.1 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91-AST"><span class="toc-text">2.2 抽象语法树 AST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E8%A7%A3%E6%9E%90%E5%99%A8%E5%9F%BA%E7%A1%80"><span class="toc-text">2.3 解析器基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%9F%BA%E7%A1%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90"><span class="toc-text">2.4 基础表达式解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E4%BA%8C%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90"><span class="toc-text">2.5 二元表达式解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E8%A7%A3%E6%9E%90%E5%89%A9%E4%B8%8B%E7%9A%84%E9%83%A8%E5%88%86"><span class="toc-text">2.6 解析剩下的部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-Driver"><span class="toc-text">2.7 Driver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E6%80%BB%E7%BB%93"><span class="toc-text">2.8 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">2.9 完整的代码</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>本章将为你展示如何使用词法分析器来构建一个完整的解析器，我们将定义和构建抽象语法树。</p>
<p>我们构建的解析器将使用<strong>递归下降解析</strong>和<strong>运算符优先级解析</strong>的来解析Kaleidoscope语言（后者用于二进制表达式，前者用于其他所有表达式），在我们开始解析之前，我们来先聊聊解析器的输出结果：抽象语法树AST。</p>
<h2 id="2-2-抽象语法树-AST"><a href="#2-2-抽象语法树-AST" class="headerlink" title="2.2 抽象语法树 AST"></a>2.2 抽象语法树 AST</h2><p>以下是一个AST的例子：</p>
<p>表达式<code>1+3*(4-1)+2</code>的抽象语法树：</p>
<p><img src="https://raw.githubusercontent.com/zhangchenqi123/imgCloud/main/img/20220912172511.png" alt="image-20220912172510969"></p>
<p>程序的AST以这样一种方式来表示一个程序：它能方便编译器后面的阶段的解析（例如代码生成）。我们希望语言中的每个构造都有一个对象，AST应该对语言进行建模。</p>
<p>在Kaileidoscope中，我们有表达式、原型和函数对象，我们先从<strong>表达式</strong>开始：</p>
<pre><code class="cpp">// ExprAST:所有表达式节点的基类。
class ExprAST &#123;
public:
  virtual ~ExprAST() &#123;&#125;
&#125;;

/// NumberExprAST - 数字的表达式类，如“1.0”
class NumberExprAST : public ExprAST &#123;
  double Val;

public:
  NumberExprAST(double Val) : Val(Val) &#123;&#125;
&#125;;
</code></pre>
<p>上面的代码展示了基本的ExprAST类的定义和我们用于数字的一个子类。关于这段代码需要注意的重要一点是NumberExprAST 类将文字的数值当做实例变量。这允许编译器的后续阶段知道存储的数值是什么。</p>
<p>现在我们只创建 AST，没有有用的访问方法。我们可以很容易的添加一个虚拟方法来漂亮地打印代码。以下是其他表达式 AST 节点定义：</p>
<pre><code class="cpp">/// VariableExprAST - 用于引用变量的表达式类，例如“a”
class VariableExprAST : public ExprAST &#123;
  std::string Name;

public:
  VariableExprAST(const std::string &amp;Name) : Name(Name) &#123;&#125;
&#125;;

/// BinaryExprAST - 二元运算的表达式类
class BinaryExprAST : public ExprAST &#123;
  char Op;
  // LHS 和 RHS 分别代表left hand side 和right hand side
  // 即操作符左边的部分和操作符右边的部分
  std::unique_ptr&lt;ExprAST&gt; LHS, RHS;

public:
  BinaryExprAST(char op, std::unique_ptr&lt;ExprAST&gt; LHS,
                std::unique_ptr&lt;ExprAST&gt; RHS)
    : Op(op), LHS(std::move(LHS)), RHS(std::move(RHS)) &#123;&#125;
&#125;;

/// CallExprAST - 函数调用的表达式
class CallExprAST : public ExprAST &#123;
  std::string Callee;
  std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args;

public:
  CallExprAST(const std::string &amp;Callee,
              std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args)
    : Callee(Callee), Args(std::move(Args)) &#123;&#125;
&#125;;
</code></pre>
<p>这一切（故意）相当简单：变量捕获变量名称，二元运算符捕获它们的操作码（例如“+”），调用捕获函数名称以及任何参数表达式的列表。我们的 AST 的优点之一是它在不讨论语言语法的情况下捕获了语言特征。请注意，这里没有讨论二元运算符的优先级、词法结构等。 对于我们的基本语言，这些是我们将定义的所有表达式节点。因为它没有条件控制流，所以它不是图灵完备的；我们将在稍后的部分中解决这个问题。接下来我们需要的两件事是一种讨论函数接口的方法，以及一种讨论函数本身的方法：</p>
<pre><code class="cpp">//这个类表示一个函数的“原型”，它捕获它的名称和它的参数名称(因此隐式地表示函数接受的参数数量)。

class PrototypeAST &#123;
  std::string Name;
  std::vector&lt;std::string&gt; Args;

public:
  PrototypeAST(const std::string &amp;name, std::vector&lt;std::string&gt; Args)
    : Name(name), Args(std::move(Args)) &#123;&#125;

  const std::string &amp;getName() const &#123; return Name; &#125;
&#125;;

/// FunctionAST - 这个类代表函数定义本身
class FunctionAST &#123;
  std::unique_ptr&lt;PrototypeAST&gt; Proto;
  std::unique_ptr&lt;ExprAST&gt; Body;

public:
  FunctionAST(std::unique_ptr&lt;PrototypeAST&gt; Proto,
              std::unique_ptr&lt;ExprAST&gt; Body)
    : Proto(std::move(Proto)), Body(std::move(Body)) &#123;&#125;
&#125;;
</code></pre>
<p>In Kaleidoscope, functions are typed with just a count of their arguments. （没懂）</p>
<p>由于所有的值都是双精度的，参数的类型不用被存储在任何地方，在更激进和显示的语言中，“ExprAST”类将有一个类型字段。</p>
<p>有了这个框架，我们现在可以解析表达式和函数体了。</p>
<h2 id="2-3-解析器基础"><a href="#2-3-解析器基础" class="headerlink" title="2.3 解析器基础"></a>2.3 解析器基础</h2><p>我们要构建AST，首先要定义解析器。假设我们想要解析类似“x+y”的东西（它将被词法分析器返回成3个token）成为一个AST，这个AST将会由一下的形式产生：</p>
<pre><code class="cpp">auto LHS = std::make_unique&lt;VariableExprAST&gt;(&quot;x&quot;);
auto RHS = std::make_unique&lt;VariableExprAST&gt;(&quot;y&quot;);
auto Result = std::make_unique&lt;BinaryExprAST&gt;(&#39;+&#39;, std::move(LHS),
                                              std::move(RHS));
</code></pre>
<p>为了做到这一点，我们从定义一些基本的helper开始</p>
<pre><code class="cpp">/// CurTok/getNextToken - P提供一个简单的token缓冲区。CurTok是解析器正在查看的当前token,getNextToken从exer读取另一个token，并用它的结果更新CurTok。
static int CurTok;
static int getNextToken() &#123;
    return CurTok = gettok();
&#125;
</code></pre>
<p>这围绕着词法分析器实现了一个简单的token缓冲区，这允许我们可以在词法分析器返回的内容中提前查看一个token，我们解析器中的每个函数都会假设CurTok是需要解析的当前token。</p>
<pre><code class="cpp">/// LogError* - 这些是用于错误处理的小辅助函数。
std::unique_ptr&lt;ExprAST&gt; LogError(const char *Str) &#123;
    fprintf(stderr, &quot;LogError: %s\n&quot;, Str);
    return nullptr;
&#125;
std::unique_ptr&lt;PrototypeAST&gt; LogErrorP(const char *Str) &#123;
    LogError(Str);
    return nullptr;
&#125;
</code></pre>
<p>LogError 程序是我们的解析器用来处理错误的简单辅助函数。我们的解析器中的错误恢复不是最好的，也不是特别友好，但对于我们的教程来说已经足够了。这些程序可以更轻松地处理具有各种返回类型的程序中的错误：它们总是返回 null。 使用这些基本的辅助函数，我们可以实现语法的第一部分：数字。</p>
<h2 id="2-4-基础表达式解析"><a href="#2-4-基础表达式解析" class="headerlink" title="2.4 基础表达式解析"></a>2.4 基础表达式解析</h2><p>对于每个产生式，我们定义了一个函数来处理它们。</p>
<p>对于数字，我们如下处理：</p>
<pre><code class="cpp">static std::unique_ptr&lt;ExprAST&gt; ParseNumberExpr() &#123;
    auto Result = std::make_unique&lt;NumberExprAST&gt;(NumVal);
    getNextToken(); // 使用了这个数字
    return std::move(Result);//std::move触发移动语义，提升性能。
&#125;
</code></pre>
<p>上面的代码很简单：当当前的token是tok_number类型的token，它被调用。获取当前数字的值，创建一个NumberExprAST节点，向前移动此法解析器到下一个token，返回。</p>
<p>这个例程返回下一个token，这是递归下降解析器的一种相当标准的方法。举个更好的例子，括号运算符的定义如下：</p>
<pre><code class="cpp">static std::unique_ptr&lt;ExprAST&gt; ParseParenExpr() &#123;
    getNextToken(); // eat (.
    auto V = ParseExpression();
    if (!V)
        return nullptr;

    if (CurTok != &#39;)&#39;)
        return LogError(&quot;expected &#39;)&#39;&quot;);
    getNextToken(); // eat ).
    return V;
&#125;
</code></pre>
<p>这个函数显示了很多关于解析器的事情：</p>
<ol>
<li><p>它显示了我们如何使用 LogError 例程。调用时，该函数期望当前token是一个’(‘token，但在解析子表达式后，可能没有’)’等待。例如，如果用户输入“（4 x”而不是“（4）”，解析器应该报出错误。因为可能发生错误，解析器需要一种方法来指示它们发生了：在我们的解析器中，我们返回错误时为空。</p>
</li>
<li><p>这个函数的另一个有趣的方面是它通过调用 ParseExpression 来使用递归（我们很快就会看到 ParseExpression 可以调用 ParseParenExpr）。这很强大，因为它允许我们处理递归语法，并使每个产生式都非常简单。请注意，括号不会导致 AST 节点本身的构造。虽然我们可以这样做，但括号最重要的作用是引导解析器并提供分组。一旦解析器构造了 AST，就不需要括号了。</p>
</li>
</ol>
<p>下一个简单的产生式用于处理<strong>变量引用</strong>和<strong>函数调用</strong>：</p>
<pre><code class="cpp">// 形式：标识符        标识符（表达式）
static std::unique_ptr&lt;ExprAST&gt; ParseIdentifierExpr() &#123;
    std::string IdName = IdentifierStr;

    getNextToken();  // 拿到下一个标识符.

    if (CurTok != &#39;(&#39;) // 简单的变量引用.
        return std::make_unique&lt;VariableExprAST&gt;(IdName);

    // 函数调用.
    getNextToken();  // eat (
    std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args;
    if (CurTok != &#39;)&#39;) &#123;
        while (1) &#123;
            if (auto Arg = ParseExpression())
                Args.push_back(std::move(Arg));
            else
                return nullptr;

            if (CurTok == &#39;)&#39;)
                break;

            if (CurTok != &#39;,&#39;)
                return LogError(&quot;Expected &#39;)&#39; or &#39;,&#39; in argument list&quot;);
            getNextToken();
        &#125;
    &#125;

    // Eat the &#39;)&#39;.
    getNextToken();

    return std::make_unique&lt;CallExprAST&gt;(IdName, std::move(Args));
&#125;
</code></pre>
<p>此例程遵循与其他例程相同的样式。 （如果当前token是 tok_identifier，它会被调用）。它还具有递归和错误处理功能。一个有趣的方面是它使用前瞻来确定当前标识符是独立变量引用还是函数调用表达式。它通过检查标识符之后的token是否是“（”来处理此问题，并根据需要构造一个 VariableExprAST 或 CallExprAST 节点。</p>
<p>现在我们已经有了所有简单的表达式解析逻辑，我们可以定义一个辅助函数来将其包装到一个入口点中。我们将此类表达式称为“基本”表达式，原因将在本教程后面更清楚地说明。为了解析任意基本表达式，我们需要确定它是什么类型的表达式：</p>
<pre><code class="cpp">static std::unique_ptr&lt;ExprAST&gt; ParsePrimary() &#123;
    switch (CurTok) &#123;
        default:
            return LogError(&quot;unknown token when expecting an expression&quot;);
        case tok_identifier:// 标识符
            return ParseIdentifierExpr();
        case tok_number:// 数字
            return ParseNumberExpr();
        case &#39;(&#39;:// 括号
            return ParseParenExpr();
    &#125;
&#125;
</code></pre>
<p>既然你看到了这个函数的定义，就更清楚为什么我们可以在各种函数中假设 CurTok 的状态。这使用前瞻来确定正在检查哪种表达式，然后使用函数调用对其进行解析。</p>
<p>现在处理了基本表达式，我们需要处理二元表达式。它们有点复杂。</p>
<h2 id="2-5-二元表达式解析"><a href="#2-5-二元表达式解析" class="headerlink" title="2.5 二元表达式解析"></a>2.5 二元表达式解析</h2><p>在上代码之前，我们先把原理讲清。</p>
<p>这部分是为了解决含有多个二元运算符的表达式的问题，例如x + y * z - k，我们不能按顺序从前往后解析，否则会解析成（x + y ) * z - k的形式，这显然与正确的运算顺序不符。</p>
<p>为了解决这个问题，我们给每个运算符定义了优先级：<code>+</code>的优先级与<code>-</code>相同，低于<code>*</code></p>
<p>先定义LHS和RHS：LHS（left hand side)为当前运算符 op 左边的式子，RHS为当前运算符右面的式子，例如，在处理a + b ，则LHS 为 a ，RHS为 b。当我们有了LHS,op,RHS，我们可以求出这个表达式的值</p>
<p>假如我们当前走到了<code>+</code>的位置，LHS为 x ，那么，我们如何判断应解析成（ x + y ) * z - k 还是 x + (y * z - k) 呢？换句话说，我们该如何判断RHS是 y 还是（y * z - k）呢？</p>
<p>这时候就要判断<code>+</code> 后面的那个运算符的优先级与<code>+</code>的关系</p>
<p>若后面的优先级小于等于当前，则RHS为当前运算符右面的那一个数 </p>
<p>若后面的更高，则RHS为后面的整体，即（y * z - k），这意味着我们要先求出来右面的整体的值。很显然，这时我们需要用到——递归。</p>
<hr>
<p>首先，我们需要一个优先级表：</p>
<pre><code class="cpp">// BinopPrecedence - 保存每个二元运算符的优先级
static std::map&lt;char, int&gt; BinopPrecedence;

/// GetTokPrecedence - 拿到在排队的二元运算符的优先级
static int GetTokPrecedence() &#123;
  if (!isascii(CurTok))
    return -1;

  // 确定这个二元运算符之前被定义过了
  int TokPrec = BinopPrecedence[CurTok];
  if (TokPrec &lt;= 0) return -1;
  return TokPrec;
&#125;

int main() &#123;
  // 定义运算符的优先级.
  // 1 的优先级最低.
  BinopPrecedence[&#39;&lt;&#39;] = 10;
  BinopPrecedence[&#39;+&#39;] = 20;
  BinopPrecedence[&#39;-&#39;] = 20;
  BinopPrecedence[&#39;*&#39;] = 40;  // 最高.
  ...
&#125;
</code></pre>
<p>对于 Kaleidoscope 的基本形式，我们将仅支持 4 个二进制运算符，他们的优先级如上。GetTokPrecedence 函数返回当前token的优先级，如果 token不是我们定义的二元运算符，则返回 -1。</p>
<p>通过上面的定义，我们现在就能解析二元表达式，操作符优先级的基本想法是<strong>把二元运算符表达式分解成一个个的小片</strong>。例如：<strong>“a+b+(c+d)*e*f+g”</strong> （这个表达式是本节的示例）。运算符优先级解析将此视为由二元运算符分隔的表达式流。因此，它将首先解析基本表达式“a”，然后它会看到对 [+, b] [+, (c+d)] [*, e] [*, f] 和 [+, g ]。请注意，括号是基本表达式，所以解析器不需要担心像 (c+d) 这样的嵌套子表达式。</p>
<p>首先，基本表达式后面可能有多个 [binop,primaryexpr] 序列对：</p>
<pre><code class="cpp">static std::unique_ptr&lt;ExprAST&gt; ParseExpression() &#123;
  auto LHS = ParsePrimary();
  if (!LHS)
    return nullptr;

  return ParseBinOpRHS(0, std::move(LHS));
&#125;
</code></pre>
<p>ParseBinOpRHS 是为我们解析后面的序列对，即RHS。这个函数传进来2个参数，假设CurTok指向运算符op1,则第一个参数ExprPrec是op1的LHS的前面一个运算符的优先级，第二个参数是LHS，例如，解析式1*2+3，如果CurTok是*，则传入参数(0,1),如果CurTok是+,则传入参数(40,2) ，其中40是*的优先级。</p>
<p>如果当前运算符的优先级小于之前运算符的优先级，则直接返回LHS，例如1 + 2 - 3，若CurTok是 + ，则RHS为2，可以直接进行1 + 2的运算。</p>
<pre><code class="cpp">static std::unique_ptr&lt;ExprAST&gt; ParseBinOpRHS(int ExprPrec,
                                              std::unique_ptr&lt;ExprAST&gt; LHS) &#123;
  // 如果这是个二元运算符，找到它的优先级
  while (1) &#123;
    int TokPrec = GetTokPrecedence();

    // 如果当前运算符的优先级小于之前运算符的优先级，
    if (TokPrec &lt; ExprPrec)
      return LHS;
</code></pre>
<p>此代码获取当前token的优先级并检查是否更低。因为我们将无效标记定义为优先级为 -1，所以此检查隐含地知道当标记流用完二元运算符时配对流结束。如果此检查成功，我们知道该标记是一个二元运算符，并且它将包含在此表达式中：</p>
<pre><code class="cpp">// 我们知道这是个二元运算符
int BinOp = CurTok;
getNextToken();  // 用掉这个二元运算符

// 解析这个二元运算符之后的表达式
auto RHS = ParsePrimary();
if (!RHS)
  return nullptr;
</code></pre>
<p>因此，这段代码用掉（并记住）二元运算符，然后解析后面的基本表达式。</p>
<p>现在，我们解析了表达式的LHS和一对RHS序列，我们要确定表达式的关联方式，可以是”(a + b)  binop unparsed”,也可以是”a + （b  binop unparsed）”,如何确定到底是哪种呢？这就要看 + 后面的那个二元操作符 binop 的优先级与 + 的优先级的大小关系。</p>
<p>如果“RHS”右侧的 binop 的优先级低于或等于我们当前运算符的优先级，那么我们知道括号关联为“(a+b) binop …”。在我们的示例中，当前运算符是“+”，下一个运算符是“+”，我们知道它们具有相同的优先级。在这种情况下，我们将为“a+b”创建 AST 节点。</p>
<p>如果binop的优先级高于我们当前的运算符优先级，则应该解析成“a + (b binop … )”，也就是用到了我们之前说的递归。</p>
<pre><code class="cpp">int NextPrec = GetTokPrecedence();
if (TokPrec &lt; NextPrec) &#123;
    RHS = ParseBinOpRHS(TokPrec+1, std::move(RHS));
    if (!RHS)
        return nullptr;
&#125;

// 融合LHS 与 RHS 为LHS
LHS = std::make_unique&lt;BinaryExprAST&gt;(BinOp, std::move(LHS),
                                      std::move(RHS));
&#125;  //  while 循环.
&#125;
</code></pre>
<h2 id="2-6-解析剩下的部分"><a href="#2-6-解析剩下的部分" class="headerlink" title="2.6 解析剩下的部分"></a>2.6 解析剩下的部分</h2><p>接下来要处理函数原型，在Kaleidoscope，这些既用于“外部”函数声明，也用于函数体定义。在Kaleidoscope，这些被用来’extern’函数定义和函数体定义。</p>
<pre><code class="cpp">static std::unique_ptr&lt;PrototypeAST&gt; ParsePrototype() &#123;
    if (CurTok != tok_identifier)
        return LogErrorP(&quot;Expected function name in prototype&quot;);

    std::string FnName = IdentifierStr;
    getNextToken();

    if (CurTok != &#39;(&#39;)
        return LogErrorP(&quot;Expected &#39;(&#39; in prototype&quot;);

    // Read the list of argument names.
    std::vector&lt;std::string&gt; ArgNames;
    while (getNextToken() == tok_identifier)
        ArgNames.push_back(IdentifierStr);
    if (CurTok != &#39;)&#39;)
        return LogErrorP(&quot;Expected &#39;)&#39; in prototype&quot;);

    // success.
    getNextToken();  // eat &#39;)&#39;.

    return std::make_unique&lt;PrototypeAST&gt;(FnName, std::move(ArgNames));
&#125;
</code></pre>
<p>有了这些，函数的定义就很简单了，就是一个原型+表达式就实现了主体。</p>
<pre><code class="cpp">static std::unique_ptr&lt;FunctionAST&gt; ParseDefinition() &#123;
    getNextToken();  // eat def.
    auto Proto = ParsePrototype();
    if (!Proto) return nullptr;

    if (auto E = ParseExpression())
        return std::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E));
    return nullptr;
&#125;
</code></pre>
<p>此外，我们支持“extern”声明“sin”和“cos”等函数，这些“extern”只是没有主体的原型：</p>
<pre><code class="cpp">/// external ::= &#39;extern&#39; 原型
static std::unique_ptr&lt;PrototypeAST&gt; ParseExtern() &#123;
    getNextToken(); 
    return ParsePrototype();
&#125;
</code></pre>
<p>顶级表达式，我们将通过为它们定义匿名空值（零参数）函数来处理这个问题：</p>
<pre><code class="cpp">static std::unique_ptr&lt;FunctionAST&gt; ParseTopLevelExpr() &#123;
    if (auto E = ParseExpression()) &#123;
        // Make an anonymous proto.
        auto Proto = std::make_unique&lt;PrototypeAST&gt;(&quot;&quot;, std::vector&lt;std::string&gt;());
        return std::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E));
    &#125;
    return nullptr;
&#125;
</code></pre>
<h2 id="2-7-Driver"><a href="#2-7-Driver" class="headerlink" title="2.7 Driver"></a>2.7 Driver</h2><p>驱动程序只需使用顶级调度循环调用所有解析片段</p>
<pre><code class="cpp">static void MainLoop() &#123;
    while (1) &#123;
        fprintf(stderr, &quot;ready&gt; &quot;);
        switch (CurTok) &#123;
            case tok_eof:
                return;
            case &#39;;&#39;:
                getNextToken();
                break;
            case tok_def:
                HandleDefinition();
                break;
            case tok_extern:
                HandleExtern();
                break;
            default:
                HandleTopLevelExpression();
                break;
        &#125;
    &#125;
&#125;
</code></pre>
<p>我们没有讲分号，其实也很简单，当输入了一行表达式之后，我们在下一行还可以继续输入这个表达式，而如果输入了分号，代表这个表达式已经输入完毕。</p>
<h2 id="2-8-总结"><a href="#2-8-总结" class="headerlink" title="2.8 总结"></a>2.8 总结</h2><p>400行，其中240行非注释或是空行，我们就定义完了我们的迷你语言，包括词法分析器、解析器、AST构造器。完成这些后，可执行文件将验证Kaleidoscope语言在语法上是否有效，例如这样：</p>
<pre><code class="bash">$ ./a.out
ready&gt; def foo(x y) x+foo(y, 4.0);
Parsed a function definition.
ready&gt; def foo(x y) x+y y;
Parsed a function definition.
Parsed a top-level expr
ready&gt; def foo(x y) x+y );
Parsed a function definition.
Error: unknown token when expecting an expression
ready&gt; extern sin(a);
ready&gt; Parsed an extern
ready&gt; ^D
$
</code></pre>
<p>在下一章中，我们将展示如何从AST生成LLVM IR。</p>
<h2 id="2-9-完整的代码"><a href="#2-9-完整的代码" class="headerlink" title="2.9 完整的代码"></a>2.9 完整的代码</h2><p>这是我们完整的代码清单，因为这使用了 LLVM 库，所以我们需要将它们链接起来，为此，我们需要使用 llvm-config工具。</p>
<pre><code class="bash"># 编译
clang++ -g -O3 toy.cpp `llvm-config --cxxflags`
# 运行
./a.out
</code></pre>
<p>完整的代码：</p>
<pre><code class="cpp">#include &lt;cctype&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

//===----------------------------------------------------------------------===//
// 词法分析器
//===----------------------------------------------------------------------===//

// token编码 - 如果见到未知种类的字符，就token值它的ascii值，否则返回以下值之一
enum Token &#123;
    // 文件结尾，token值为-1
    tok_eof = -1,

    // 关键字“def”的token值为-2
    // 关键字“extern&quot;的token值为-3
    tok_def = -2,
    tok_extern = -3,

    // 标识符（变量、常量、函数名）的token值为-4
    // 数字类型的token值为-5
    tok_identifier = -4,
    tok_number = -5
&#125;;

static std::string IdentifierStr; // Filled in if tok_identifier
static double NumVal;             // Filled in if tok_number

/// gettok - 找到下一个词法单元，返回其token编码
static int gettok() &#123;
    static int LastChar = &#39; &#39;;

    // Skip any whitespace.
    while (isspace(LastChar))
        LastChar = getchar();

    // 字母开头的，可能是def，可能是extern，可能是标识符
    if (isalpha(LastChar)) &#123; // identifier: [a-zA-Z][a-zA-Z0-9]*
        IdentifierStr = LastChar;
        while (isalnum((LastChar = getchar())))
            IdentifierStr += LastChar;

        if (IdentifierStr == &quot;def&quot;)
            return tok_def;
        if (IdentifierStr == &quot;extern&quot;)
            return tok_extern;
        return tok_identifier;
    &#125;

    // 数字
    if (isdigit(LastChar) || LastChar == &#39;.&#39;) &#123; // Number: [0-9.]+
        std::string NumStr;
        do &#123;
            NumStr += LastChar;
            LastChar = getchar();
        &#125; while (isdigit(LastChar) || LastChar == &#39;.&#39;);

        NumVal = strtod(NumStr.c_str(), nullptr);
        return tok_number;
    &#125;

    // 注释
    if (LastChar == &#39;#&#39;) &#123;
        // 注释是从当前位置到本行的结尾
        do
            LastChar = getchar();
        while (LastChar != EOF &amp;&amp; LastChar != &#39;\n&#39; &amp;&amp; LastChar != &#39;\r&#39;);

        if (LastChar != EOF)
            return gettok();
    &#125;

    // 检查文件的结尾
    if (LastChar == EOF)
        return tok_eof;

    // 否则，就返回这个字符对应的ascii值
    int ThisChar = LastChar;
    LastChar = getchar();
    return ThisChar;
&#125;

//===----------------------------------------------------------------------===//
// AST 抽象语法树
//===----------------------------------------------------------------------===//

namespace &#123;

    /// ExprAST - 所有表达式节点的基类。
    class ExprAST &#123;
        public:
        virtual ~ExprAST() = default;
    &#125;;

    /// NumberExprAST - 表达式类，用于类似的数字字面值像 &quot;1.0&quot;.
    class NumberExprAST : public ExprAST &#123;
        double Val;

        public:
        NumberExprAST(double Val) : Val(Val) &#123;&#125;
    &#125;;

    /// VariableExprAST - 表达式类，用于类似的变量值像 &quot;a&quot;.
    class VariableExprAST : public ExprAST &#123;
        std::string Name;

        public:
        VariableExprAST(const std::string &amp;Name) : Name(Name) &#123;&#125;
    &#125;;

    /// BinaryExprAST - 表达式类，用于二元操作符
    class BinaryExprAST : public ExprAST &#123;
        char Op;
        std::unique_ptr&lt;ExprAST&gt; LHS, RHS;

        public:
        BinaryExprAST(char Op, std::unique_ptr&lt;ExprAST&gt; LHS,
                      std::unique_ptr&lt;ExprAST&gt; RHS)
            : Op(Op), LHS(std::move(LHS)), RHS(std::move(RHS)) &#123;&#125;
    &#125;;

    /// CallExprAST - 表达式类，用于函数调用
    class CallExprAST : public ExprAST &#123;
        std::string Callee;
        std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args;

        public:
        CallExprAST(const std::string &amp;Callee,
                    std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args)
            : Callee(Callee), Args(std::move(Args)) &#123;&#125;
    &#125;;

    /// PrototypeAST - 一个函数的原型AST，获得函数名、参数名（隐式的表达了函数接收参数的数量）
    class PrototypeAST &#123;
        std::string Name;
        std::vector&lt;std::string&gt; Args;

        public:
        PrototypeAST(const std::string &amp;Name, std::vector&lt;std::string&gt; Args)
            : Name(Name), Args(std::move(Args)) &#123;&#125;

        const std::string &amp;getName() const &#123; return Name; &#125;
    &#125;;

    /// FunctionAST - 这个类代表函数定义
    class FunctionAST &#123;
        std::unique_ptr&lt;PrototypeAST&gt; Proto;
        std::unique_ptr&lt;ExprAST&gt; Body;

        public:
        FunctionAST(std::unique_ptr&lt;PrototypeAST&gt; Proto,
                    std::unique_ptr&lt;ExprAST&gt; Body)
            : Proto(std::move(Proto)), Body(std::move(Body)) &#123;&#125;
    &#125;;

&#125; // namespace

//===----------------------------------------------------------------------===//
// 解析器
//===----------------------------------------------------------------------===//

// CurTok/getNextToken - 提供一个简单的token缓冲. CurTok是当前parser正在用的token
// getNextToken是lexer读的另一个token,要用它的值来更新CurTok的值
static int CurTok; // CurTok是个全局变量！！
static int getNextToken() &#123; return CurTok = gettok(); &#125;

/// BinopPrecedence - 二元操作符的优先级
static std::map&lt;char, int&gt; BinopPrecedence;

/// GetTokPrecedence - 获得二元运算符的优先级
static int GetTokPrecedence() &#123;
    if (!isascii(CurTok))
        return -1;

    // 确保它是被定义过的
    int TokPrec = BinopPrecedence[CurTok];
    if (TokPrec &lt;= 0)
        return -1;
    return TokPrec;
&#125;

/// LogError* - 错误处理函数
std::unique_ptr&lt;ExprAST&gt; LogError(const char *Str) &#123;
    fprintf(stderr, &quot;Error: %s\n&quot;, Str);
    return nullptr;
&#125;
std::unique_ptr&lt;PrototypeAST&gt; LogErrorP(const char *Str) &#123;
    LogError(Str);
    return nullptr;
&#125;

static std::unique_ptr&lt;ExprAST&gt; ParseExpression();

/// numberexpr ::= 数字
static std::unique_ptr&lt;ExprAST&gt; ParseNumberExpr() &#123;
    auto Result = std::make_unique&lt;NumberExprAST&gt;(NumVal);
    getNextToken(); 
    return std::move(Result);
&#125;

/// parenexpr ::= 括号 &#39;(&#39; 表达式 &#39;)&#39;
static std::unique_ptr&lt;ExprAST&gt; ParseParenExpr() &#123;
    getNextToken(); // eat (.
    auto V = ParseExpression();
    if (!V)
        return nullptr;

    if (CurTok != &#39;)&#39;)
        return LogError(&quot;expected &#39;)&#39;&quot;);
    getNextToken(); // eat ).
    return V;
&#125;

/// identifierexpr
///   ::= 标识符
///   ::= 标识符 &#39;(&#39; 表达式* &#39;)&#39;
static std::unique_ptr&lt;ExprAST&gt; ParseIdentifierExpr() &#123;
    std::string IdName = IdentifierStr;

    getNextToken(); // 消费掉标识符

    if (CurTok != &#39;(&#39;) // 简单的变量引用
        return std::make_unique&lt;VariableExprAST&gt;(IdName);

    // 函数调用.
    getNextToken(); // eat (
    std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args;
    if (CurTok != &#39;)&#39;) &#123;
        while (true) &#123;
            if (auto Arg = ParseExpression())
                Args.push_back(std::move(Arg));
            else
                return nullptr;

            if (CurTok == &#39;)&#39;)
                break;

            if (CurTok != &#39;,&#39;)
                return LogError(&quot;Expected &#39;)&#39; or &#39;,&#39; in argument list&quot;);
            getNextToken();
        &#125;
    &#125;

    // Eat the &#39;)&#39;.
    getNextToken();

    return std::make_unique&lt;CallExprAST&gt;(IdName, std::move(Args));
&#125;

/// primary
///   ::= 标识符表达式
///   ::= 数字表达式
///   ::= 括号表达式
static std::unique_ptr&lt;ExprAST&gt; ParsePrimary() &#123;
    switch (CurTok) &#123;
        default:
            return LogError(&quot;unknown token when expecting an expression&quot;);
        case tok_identifier:
            return ParseIdentifierExpr();
        case tok_number:
            return ParseNumberExpr();
        case &#39;(&#39;:
            return ParseParenExpr();
    &#125;
&#125;


static std::unique_ptr&lt;ExprAST&gt; ParseBinOpRHS(int ExprPrec,
                                              std::unique_ptr&lt;ExprAST&gt; LHS) &#123;
    // 如果这是个二元运算符，找到它的优先级
    while (1) &#123;
        int TokPrec = GetTokPrecedence();

        // 如果当前运算符的优先级小于之前运算符的优先级，
        if (TokPrec &lt; ExprPrec)
            return LHS;
        // 我们知道这是个二元运算符
        int BinOp = CurTok;
        getNextToken();  // 用掉这个二元运算符

        // 解析这个二元运算符之后的表达式
        auto RHS = ParsePrimary();
        if (!RHS)
            return nullptr;
        int NextPrec = GetTokPrecedence();
        if (TokPrec &lt; NextPrec) &#123;
            RHS = ParseBinOpRHS(TokPrec+1, std::move(RHS));
            if (!RHS)
                return nullptr;
        &#125;

        // 融合LHS 与 RHS 为LHS
        LHS = std::make_unique&lt;BinaryExprAST&gt;(BinOp, std::move(LHS),
                                              std::move(RHS));
    &#125;  //  while 循环.
&#125;



/// expression
///   ::= primary binoprhs
///
static std::unique_ptr&lt;ExprAST&gt; ParseExpression() &#123;
    auto LHS = ParsePrimary();
    if (!LHS)
        return nullptr;

    return ParseBinOpRHS(0, std::move(LHS));
&#125;

/// prototype
///   ::= id &#39;(&#39; id* &#39;)&#39;
static std::unique_ptr&lt;PrototypeAST&gt; ParsePrototype() &#123;
    if (CurTok != tok_identifier)
        return LogErrorP(&quot;Expected function name in prototype&quot;);

    std::string FnName = IdentifierStr;
    getNextToken();

    if (CurTok != &#39;(&#39;)
        return LogErrorP(&quot;Expected &#39;(&#39; in prototype&quot;);

    std::vector&lt;std::string&gt; ArgNames;
    while (getNextToken() == tok_identifier)
        ArgNames.push_back(IdentifierStr);
    if (CurTok != &#39;)&#39;)
        return LogErrorP(&quot;Expected &#39;)&#39; in prototype&quot;);

    // success.
    getNextToken(); // eat &#39;)&#39;.

    return std::make_unique&lt;PrototypeAST&gt;(FnName, std::move(ArgNames));
&#125;

/// definition ::= &#39;def&#39; 原型表达式
static std::unique_ptr&lt;FunctionAST&gt; ParseDefinition() &#123;
    getNextToken(); // eat def.
    auto Proto = ParsePrototype();
    if (!Proto)
        return nullptr;

    if (auto E = ParseExpression())
        return std::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E));
    return nullptr;
&#125;

/// toplevelexpr ::= expression
static std::unique_ptr&lt;FunctionAST&gt; ParseTopLevelExpr() &#123;
    if (auto E = ParseExpression()) &#123;
        // Make an anonymous proto.
        auto Proto = std::make_unique&lt;PrototypeAST&gt;(&quot;__anon_expr&quot;,
                                                    std::vector&lt;std::string&gt;());
        return std::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E));
    &#125;
    return nullptr;
&#125;

/// external ::= &#39;extern&#39; 原型
static std::unique_ptr&lt;PrototypeAST&gt; ParseExtern() &#123;
    getNextToken(); // eat extern.
    return ParsePrototype();
&#125;

//===----------------------------------------------------------------------===//
// Top-Level parsing
//===----------------------------------------------------------------------===//

static void HandleDefinition() &#123;
    if (ParseDefinition()) &#123;
        fprintf(stderr, &quot;Parsed a function definition.\n&quot;);
    &#125; else &#123;
        // 跳过错误恢复的token
        getNextToken();
    &#125;
&#125;

static void HandleExtern() &#123;
    if (ParseExtern()) &#123;
        fprintf(stderr, &quot;Parsed an extern\n&quot;);
    &#125; else &#123;
        // 跳过错误恢复的token
        getNextToken();
    &#125;
&#125;

static void HandleTopLevelExpression() &#123;
    if (ParseTopLevelExpr()) &#123;
        fprintf(stderr, &quot;Parsed a top-level expr\n&quot;);
    &#125; else &#123;
        // 跳过错误恢复的token
        getNextToken();
    &#125;
&#125;

/// top ::= 定义| external | 表达式 | &#39;;&#39;
static void MainLoop() &#123;
    while (true) &#123;
        fprintf(stderr, &quot;ready&gt; &quot;);
        switch (CurTok) &#123;
            case tok_eof:
                return;
            case &#39;;&#39;: // ignore top-level semicolons.
                getNextToken();
                break;
            case tok_def:
                HandleDefinition();
                break;
            case tok_extern:
                HandleExtern();
                break;
            default:
                HandleTopLevelExpression();
                break;
        &#125;
    &#125;
&#125;

//===----------------------------------------------------------------------===//
// Main 函数
//===----------------------------------------------------------------------===//

int main() &#123;
    // 定义运算符的优先级，1是最小的
    BinopPrecedence[&#39;&lt;&#39;] = 10;
    BinopPrecedence[&#39;+&#39;] = 20;
    BinopPrecedence[&#39;-&#39;] = 20;
    BinopPrecedence[&#39;*&#39;] = 40; // 最高的.

    fprintf(stderr, &quot;ready&gt; &quot;);
    getNextToken();

    // 运行主循环
    MainLoop();

    return 0;
&#125;
</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 1149440709@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>




    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: 'a21e1504f7be0f6a38fb',
            clientSecret: 'ef1fe010e546f46a175af54e364ab38228d2fa69',
            repo: 'zhangchenqi123.github.io',
            owner: 'zhangchenqi123',
            admin: ['zhangchenqi123'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©022 张辰琦
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
